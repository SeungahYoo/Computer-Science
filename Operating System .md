##Ch2. 컴퓨터의 구조와 성능 향상



####CPU의 명령어 처리 과정

~~~javascript
LOAD mem(100), register 2; //메모리의 100번지에 있는 값을 레지스터 2로 가져온다.
LOAD mem(120), register 3; //메모리의 120번지에 있는 값을 제리스터 3으로 가져온다.
ADD register 5, register 2, register 3; //레지스터 2와 레지스터 3에 저장된 값의 합을 레지스터 5에 저장
MOVE register 5, mem(160); //레지스터 5의 값을 메모리의 160번지로 옮긴다.
~~~

CPU가 연산을 하려면 필요한 데이터를 CPU로 가져와 임시로 보관해야 하는데, 이때 사용되는 장소가 레지스터.

제어장치는 명령어를 해석하여 제어 신호를 보내고 CPU 내의 데이터 흐름을 조절하는 역할



#### 버스의 종류

버스는 CPU와 메모리, 주변 장치 간에 데이터를 주고받을 때 사용.

- 제어버스(control bus)

  제어장치와 연결된 버스로, CPU가 메모리와 주변 장치에 제어 신호를 보내기 위해 사용. 메모리와 주변 장치에서도 작업이 완료되거나 오류가 발생하면 제어신호를 보내기때문에 **양방향**이다.

- 주소버스(address bus)

  메모리 주소 레지스터와 연결된 버스로, 메모리나 주변장치에 데이터를 읽고 쓸 때 위치 정보를 보내기 위해 사용. **단방향**

- 데이터버스(data bus)

  메모리 버퍼 레지스터와 연결된 버스로, 데이터의 이동이 **양방향**으로 이루어진다.



####인터럽트

- polling : CPU가 직접 입출력장치에서 데이터를 가져오거나 내보내는 것.

- CPU작업과 저장장치의 데이터 이동을 독립적으로 운영함으로써 시스템의 효율을 높인다.

- 동작 과정

  1. CPU가 입출력 관리자에게 입출력 명령을 보낸다.
  2. 입출력 관리자는 명령받은 데이터를 메모리에 가져다놓거나 메모리에 있는 데이터를 저장장치에 옮긴다.
  3. 데이터 전송이 완료되면 입출력 관리자는 완료 신호(인터럽트)를 CPU에 보낸다.

  4. CPU는 하던 일을 중단하고 옮겨진 데이터를 처리한다.

- 인터럽트 벡터

  - CPU는 입출력 관리자에게 여러 개의 입출력 작업을 동시에 시킬 수 있다.
  - 여러 작업이 동시에 완료되었을 때 효율적으로 인터럽트를 사용하기 위함.
  - 인터럽트 벡터에 넘버로 각각의 인터럽트 구분, 완료/비완료 상태를  백터 통째로 CPU에게 전송.

- DMA(Direct Memory Access, 직접 메모리 접근)

  메모리는 CPU만 접근 권한을 가진 작업공간이라 입출력 관리자는 접근이 불가하다.

  따라서 CPU의 허락 없이 메모리에 접근할 수 있는 권한을 DMA라고 한다.


####병렬 처리(Parallel processing)

- 여러 개의 스레드를 동시에 처리하는 방법을 CPU multi-thread라고 한다.

- CPU에서 명령어가 실행되는 과정

  1. 명령어 패치(Instruction Fetch, **IF**) : 다음에 실행할 명령어를 명령어 레지스터에 저장
  2. 명령어 해석(Instruction Decode, **ID**) : 명령어를 해석
  3. 실행(EXecution, **EX**) : 해석한 결과를 토대로 명령어 실행
  4. 쓰기(Write Back,**WB**) : 실행된 결과를 메모리에 저장

- 병렬 처리 기법

  - 파이프라인 기법(pipeline) = 하이퍼스레드(Hyper-Thread)

    명령어를 읽어 순차적으로 실행하는 프로세서에 적용되는 기술로, 한 번에 하나의 명령어만 실행하는 것이 아니라 하나의 명령어가 실행되는 도중에 다른 명령어 실행을 시작하는 식으로 동시에 여러 개의 명령어를 실행하는 기법이다.



    <img src="https://upload.wikimedia.org/wikipedia/commons/2/21/Fivestagespipeline.png" width="350px"/>

  - 

    - 데이터 해저드(data hazard)

      데이터 의존성 때문에 발생하는 문제. 데이터 A를 필요로 하는 두번째 명령어는 앞의 명령어(A)가 끝날 때까지 동시에 실행되어서는 안된다. 

      파이프라인의 명령어 단계를 지연하여 해결.

    - 제어 해저드(control hazard)

      if문 혹은 goto문 처럼 분기를 하는 명령에서 발생. 명령어가 순차적으로 실행되지 않고 다른 문장으로 이동하게 되면 현재 동시에 처리되고 있는 명령어들이 쓸모 없어진다. 

      분기 예측이나 분기 지연 방법으로 해결

    - 구조 해저드(structural hazard)

      서로 다른 명령어가 같은 자원에 접근하려 할 때 발생하는 문제



   - 슈퍼스칼라(super-scalar)기법

     파이프라인을 처리할 수 있는 코어를 여러 개 구성하여 복수의 명령어가 동시에 실행되도록 하는 방식.

     코어를 2개 구성하여 각 단계에서 동시에 실행되는 명령어가 2개.



     <img src="https://upload.wikimedia.org/wikipedia/commons/c/ce/Superscalarpipeline.png" width="350px"/>







##Ch3. 프로세스와 스레드



프로그램은 저장장치에 저장되어 있는 정적인 상태이고, 프로세스는 실행을 위해 메모리에 올라온 동적인 상태이다.



####프로세스의 상태

- 생성 : 프로그램을 메모리에 가져와 실행 준비가 완료된 상태
- 준비 : 실행을 기다리는 모든 프로세스가 자기 차례를 기다리는 상태. 실행될 프로세스를 CPU 스케줄러가 선택한다.
- 실행 : 선택된 프로세스가 타임 슬라이스를 얻어 CPU를 사용하는 상태. 프로세스 사이의 context switching 발생
- 대기 : 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태. 입출력이 완료되면 준비 상태로 간다.
- 완료 : 프로세스 종료. 정상종료 exit, 비정상 종료 abort



####PCB(Process Control Block)

모든 프로세스는 고유한 PCB를 가진다. 프로세스 생성 시 만들어져 프로세스가 실행을 완료하면 폐기

포인터, 프로세스 상태, 프로세스 구분자, 프로그램 카운터, 우선순위, 각종 레지스터 정보 ...



####문맥교환(Context Switching)

CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업.





####프로세스의 구조

<img src="https://t1.daumcdn.net/cfile/tistory/267EE53F5882D9CE3F" width="200px"/>

* 코드영역

  프로그래머가 작성한 프로그램. 읽기 전용으로 처리. 자기 자신을 수정하는 프로그램은 존재X..

* 데이터영역

  프로그램이 사용하려고 정의한 변수(전역변수), 파일 등 각종 데이터. 읽기/쓰기 가능

==> 코드영역과 데이터 영역은 프로세스가 실행되기 직전에 위치와 크기가 결정되고 실행되는 동안 변하지 않으므로 정적할당 역역이라고 부른다.

* 힙 영역

  - 동적으로 할당되는 변수 영역 ex)malloc

    ~~~ c
    main(){
        int sarr[50];
        int *darr;
        
        darr=(int*)malloc(sizeof(int)*50);
        
        free(darr); //메모리 반환
    }
    ~~~

* 스택영역

  부수적으로 필요한 데이터. 복구 위치 등. 사용자에게는 보이지 않는다.

  - 호출한 함수가 종료되면 복귀 주소를 스택에 저장한다.
  - 변수 사용 범위에 영향을 미치는 영역을 구현할 때 사용. 지역변수 저장

==> 스택영역과 힙영역은 프로세스가 실행되는 동안 만들어지는 영역으로, 그 크기가 늘어났다 줄어들기도 하는 동적할당 영역이다. 





####fork()

실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수. 커널에서 제공. 시스템 호출의 일종

실행하던 프로세스는 부모프로세스, 새로 생긴 프로세스는 자식 프로세스로서 부모-자식 관계

* 장점

  * 프로세스의 생성 속도가 빠르다.
  * 추가 작업 없이 자원을 상속할 수 있다.
  * 시스템 관리를 효율적으로 할 수 있다.


####exec()

기존의 프로세스를 새로운 프로세스로 전환하는 함수.

프로세스의 구조체를 재활용하기 위함이다. 새로운 프로세스를 만들려면 PCB를 만들고 메모리의 자리를 확보하는 과정이 필요하다. 이때 exec() 시스템 호출을 사용하면 이미 만들어진 PCB, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있어 편리하다.



####스레드

프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위

- 프로세스 vs 스레드

  프로세스는 약하게 연결(독립적)되어 있는 반면 스레드기리는 강하게 연결되어있다.

  프로세스 : 죽 / 안심 / 케이크     스레드 : 고기 굽기 / 채소 굽기 / 소스 뿌리기

  - 멀티스레드

    프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법.

  - 멀티태스킹

    운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법.

  - 멀티프로세싱

    CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경. = 슈퍼스칼라 기법

  - CPU 멀티스레드

    파이프라인을 기법을 이용하여 도잇에 여러 스레드를 처리하도록 만든 병렬 처리 기법.



  ​	*정적영역 : 프로세스가 실행되는 동안 바뀌지 않는 영역

  - fork() 시스템 호출로 여러 개의 프로세스를 만들면 필요 없는 정적 영역이 여러 개가 된다. 이 문제를 해결하기 위해 하나의 프로세스 내에 여러 개의 스레드를 생성하는 멀티스레드는 코드, 파일등의 자원을 공유함으로써 자원의 낭비를 막고 효율성을 향상한다.	

  <img src="https://www.studytonight.com/operating-system/images/single-and-multithreaded-process.png" width=400px/>



####멀티스레드의 장단점

- 장점
  - 응답성 향상 : 한 스레드가 입출력으로 인해 작업이 진행되지 않더라도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답할 수 있다.
  - 자원 공유 : 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원활하게 진행할 수 있다.
  - 효율성 향상 : 자원의 중복을 막음으로써 효율 향상
  - 다중 CPU 지원 : 2개 이상의 CPU를 가진 컴퓨터에서 멀티스레드를 사용하면 프로세스의 처리 시간이 단축된다.
- 단점
  - 모든 스레드가 자원을 공유하기 때문에 한 스레드에 문제가 생기면 전체 프로세스에 영향을 미친다.



####멀티스레드 모델

- 사용자 스레드(user-level thread)

  <img src="https://i.stack.imgur.com/QAfYU.jpg" width=250px/>

  - 사용자 레벨에서 스레드를 구현하기 때문에 관련 라이브러리를 사용하여 구현.

  - 커널 입장에서 하나의 프로세스처럼 보인다. 사용자 프로세스 내에 여러개의 스레드가 존재하지만 커널의 스레드 하나와 연결된다.

  - 라이브러리가 직접 스케줄링하고 작업에 필요한 정보를 처리하기 때문에 context switching X

  - 장점  문맥교환과 같은 부가적인 작업이 줄어들어 속도가 빠르다.

  - 단점 

    여러개의 스레드가 하나의 커널 스레드와 연결되기 때문에 커널 스레드가 입출력 작업을 위해 대기 상태에 들어가면 모든 사용자 스레드가 대기하게 된다.

    한 프로세스의 타임 슬라이스를 여러 스레드가 공유하기 때문에 여러 개의 CPU를 동시에 사용할 수 없다.

    보안에 취약하다.


- 커널 스레드(kernel-level thread)

  ![ê´ë ¨ ì´ë¯¸ì§](https://professormerwyn.files.wordpress.com/2015/08/one-to-one.jpg?w=260)

  - 커널이 멀티스레드를 지원하는 방식으로, 하나의 사용자 스레드가 하나의 커널스레드와 연결된다.
  - 멀티 CPU 사용 가능, 하나의 스레드가 대기 상태에 있어도 다른 스레드는 작업을 계속 할 수 있다. 보안에 강하고 안정적
  - 문맥교환 오버헤드(단점)

- 멀티레벨 스레드

  - 사용자 레벨 스레드와 커널 레벨 스레드를 혼합한 방식으로 하이브리드 스레드라고도 한다.







## CH4. CPU Scheduling

모든 프로세스가 공평하게 작업하도록 하는 것



#### 선점형 스케줄링과 비선점형 스케줄링

- 선점형 스케줄링 "빼앗을 수 있음"

  어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식

- 비선점형 스케줄링 "빼앗을 수 없음"

  다른 프로세스가 빼앗을 수 없는 스케줄링 방식

  | 구분      | 선점형                                          | 비선점형                                               |
  | :-------- | :---------------------------------------------- | ------------------------------------------------------ |
  | 작업 방식 | 작업을 중단시키고 새로운 작업을 실행할 수 있다. | 실행 상태에 있는 작업이 완료될때까지 다른 작업 불가능  |
  | 장점      | 대화형이나 시분할 시스템에 적합                 | CPU 스케줄러의 작업량이 적고 문맥 교환 오버헤드가 적다 |
  | 단점      | 오버헤드 많다                                   | 기다리는 프로세스가 많아 처리율이 떨어진다.            |
  | 사용      | 시분할 방식 스케줄러                            | 일괄 작업 방식 스케줄러                                |
  | 중요도    | 높다                                            | 낮다                                                   |



#### 다중 큐

- 준비 상태의 다중 큐
  - 고정 우선순위 방식

    운영체제가 프로세스에 우선순위를 부여하면 프로세스가 끝날 때까지 바뀌지 않는 방식

  - 변동 우선순위 방식

    프로세스 생성 시 부여받은 우선순위가 프로세스 작업 중간에 변하는 방식

- 대기 상태의 다중 큐





####스케줄링 알고리즘

- 비선점형 알고리즘

  FCFS, SJF, HRN

- 선점형 알고리즘

  라운드로빈, SRT, 다단계 큐, 다단계 피드백 큐

- 둘 다 가능

  우선순위 스케줄링





### 공유자원

- 여러프로세스가 공동으로 이용하는 변수, 메모리, 파일 등
- 누가 언제 데이터를 읽거나 쓰느냐에 따라 그 결과가 달라질 수 있다.



### 임계구역

- 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역

- 임계구역 해결 조건

  1) 상호배제(mutual exlusion)

  ​	임계구역 내에는 한 번에 하나의 프로세스만 존재

  2) 한정 대기(bounded waiting)

  ​	어떤 프로세스도 무한대기 하지 않아야 한다. 

  ​	즉 특정 프로세스가 임계구역에 진입하지 못하면 안된다.

  3) 진행의 융통성(progress flexibility)

  ​	한 프로세스가 다른 프로세스의 진행을 방해해서는 안 된다.

### 임계구역의 해결 방법

~~~c
#include <stdio.h>

bool lock = false;
int balance;

int main(){
    while(lock==true);
        lock=true;
        balance = balance+10; /* 임계구역 */
        lock = false;
    
}
~~~



* 피터슨 알고리즘

  프로세스 P1은 임계구역에 진입하기 전에 먼저 잠금을 한 후 turn을 2로 설정한다. 변수 turn은 두 프로세스가 동시에 lock을 설정하여 임계구역에 못 들어가는 상황에 대비하기 위한 장치이다. 즉 두 프로세스가 동시에 lock을 설정했더라도 turn을 사용하여 다른 프로세스에 양보한다.

  이어서 while

* 데커 알고리즘

  ~~~c
  lock1 = true;
  while(lock2==true){
      if(turn ==2){
          lock1=false;
          while(turn==2);
          lock1=true;}
      }
  		/*~~~~~임계구역~~~~~*/
  turn=2;
  lock1=false;
  }
  ~~~

* 세마포어

* 모니터